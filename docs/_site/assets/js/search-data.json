{"0": {
    "doc": "Code to generate documentation for dame-flame",
    "title": "Code to generate documentation for dame-flame",
    "content": "# Code to generate documentation for `dame-flame` This directory contains the code for the web site as displayed at https://almost-matching-exactly.github.io/DAME-FLAME-Python-Package/ Please go to that site to view the documentation. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/",
    "relUrl": "/"
  },"1": {
    "doc": "FAQ and Vocabulary Guide",
    "title": "FAQ and Vocabulary Guide",
    "content": ". | Vocabulary Guide | FAQ . | Why Don’t You Support Continuous Data? | Why doesn’t the machine learning step support my preferred method? | Why doesn’t the package have any built-in visualization methods? | Why should I use this instead of another package? Other ones seem more common! | I have a question not covered here | . | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/FAQ",
    "relUrl": "/FAQ"
  },"2": {
    "doc": "FAQ and Vocabulary Guide",
    "title": "Vocabulary Guide",
    "content": "We briefly define some of the terms we use interchangeably throughout this User Guide and in this documentation below. | Unit, Observation, Individual | A participant in the research trial, in either the control group or treatment group, for whom we have an observed outcome | . | Covariate, Observed data, X’s, Independent variables | The data we observe which is not the treatment group or the outcome | . | Outcome, Y, Dependent variables | The outcome variable of the research | . | Treated Unit | A unit which is in the treatment group | . | Treatment Effects | We have a whole page on this. See here. | . | Matched group, matches | The group that a unit is assigned to based on the result of the matching algorithm | . | Main matched group | If units are assigned to multiple groups, each group has one group which is its main group, in which it is matched to units which it is most similar to. Other groups it is in will have less similar covariates | . | Input dataset, matching dataset | The dataset on which matches will be made | . | Holdout training data, holdout data, training data | The dataset that will be used to compute predictive error (PE) in deciding which covariates to match on. In future versions of the code, this will be called “training data”. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/FAQ#vocabulary-guide",
    "relUrl": "/FAQ#vocabulary-guide"
  },"3": {
    "doc": "FAQ and Vocabulary Guide",
    "title": "FAQ",
    "content": "Why Don’t You Support Continuous Data? . The FLAME and DAME algorithms use Hamming distance as the distance metric, which is only relevant for discrete data. If you have continuous data, we provide recommendations on discretizations here: here. Why doesn’t the machine learning step support my preferred method? . At this time, we have provided implementations for three options: ridge regressions with a pre-specified alpha, ridge regressions with cross validation, and decision trees. We chose these based on what we know researchers want at this time. We definitely would love to add more if you wish! Please see our contributing guide. Why doesn’t the package have any built-in visualization methods? . Visualizing data is a valuable tool to understanding it before and after performing any analysis like matching. While the DAME-FLAME package doesn’t have built in functions to visualize the data, we provide several examples of ways that researchers could visualize any dataset, before and after matching. This is a listing: . | A histogram depicting the size of the matched group of each unit here | A scatter plot of true vs estimated CATT for units in a matched dataset here | A bar chart depicting the treatment effects of different matched groups here | A histogram depicting the size of each matched group here | A histogram of the number of units matched on each covariate, to help interpret covariate importance here | . For each of these, we provide a link to our github repository, and encourage users to fork the code and visualize your own data. Why should I use this instead of another package? Other ones seem more common! . The matches produced by the dame-flame package are higher quality. dame-flame doesn’t use uninterpretable propensity scores, it matches on actual covariates. It doesn’t require the user to specify the metric like CEM, since it uses machine learning to learn the metric adaptively. It is not based on a black box machine learning method like Causal Forest or BART, but it can often be just as accurate, and it’s much easier to troubleshoot! [1] [2]. You can see our simulation here comparing dame-flame against MatchIt’s propensity score matching. This simulation shows that our package results in higher-quality matches. Also, the features of the dame-flame package are really useful. We offer several built-in treatment effect estimators so that users don’t have to rely on other packages or compute their own, and we offer built-in missing data handling. We offer recommendations for customizing the algorithm’s features for your specific needs here, here, and here. You can be confident that the package will run smoothly. Our test suite, powered by Travis’ Continuous Integration, covers over 98% of the code. We have also confirmed consistent results with the package R-FLAME, available on GitHub here. I have a question not covered here . Please reach out to let our team know if you’re using this, or if you have any questions. We welcome public comments or questions on GitHub through the Issue Tracker here, or feel free to contact Neha Gupta at neha.r.gupta “at” duke “dot” edu. References . [1] Wang, Morucci, et al. FLAME: A Fast Large-scale Almost Matching Exactly Approach to Causal Inference. [2] Liu, Dieng, et al. Interpretable Almost Matching Exactly For Causal Inference. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/FAQ#faq",
    "relUrl": "/FAQ#faq"
  },"4": {
    "doc": "DAME",
    "title": "dame_flame.matching.DAME",
    "content": "class dame_flame.matching.DAME(adaptive_weights='ridge', alpha=0.1, repeats=True, verbose=2, early_stop_iterations=False, stop_unmatched_c=False, early_stop_un_c_frac=False, stop_unmatched_t=False, early_stop_un_t_frac=False, early_stop_pe=False, early_stop_pe_frac=0.01, missing_indicator=np.nan, missing_data_replace=0, missing_holdout_replace=0, missing_holdout_imputations=10, missing_data_imputations=1, want_pe=False, want_bf=False) . Source Code . This class creates the matches based on the DAME “Dynamic Almost Matching Exactly” algorithm. It has built in support for stopping criteria and missing data handling. Read more in the User Guide . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/DAME#dame_flamematchingdame",
    "relUrl": "/api-documentation/DAME#dame_flamematchingdame"
  },"5": {
    "doc": "DAME",
    "title": "Parameters",
    "content": "| Parameter Name | Type | Default | Description | . | adaptive_weights | {bool, ‘ridge’, ‘decisiontree’, ‘ridgeCV’, ‘decisiontreeCV’} | ‘ridge’ | The method used to decide what covariate set should be dropped next. | . | alpha | float | 0.1 | If adaptive_weights is set to ridge, this is the alpha for ridge regression. | . | repeats | bool | True | Whether or not units for whom a main matched has been found can be used again, and placed in an auxiliary matched group. | . | verbose | int: {0,1,2,3} | 2 | Style of printout while algorithm runs. If 0, no output. If 1, provides iteration number. If 2, provides iteration number and additional information on the progress of the matching at every 10th iteration. If 3, provides iteration number and additional information on the progress of the matching at every iteration | . | early_stop_iterations | int | 0 | If provided, a number of iterations after which to hard stop the algorithm. | . | stop_unmatched_c | bool | False | If True, then the algorithm terminates when there are no more control units to match. | . | stop_unmatched_t | bool | False | If True, then the algorithm terminates when there are no more treatment units to match. | . | early_stop_un_c_frac | float | 0.1 | Must be between 0.0 and 1.0. This provides a fraction of unmatched control units. When the threshold is met, the algorithm will stop iterating. For example, using an input dataset with 100 control units, the algorithm will stop when 10 control units are unmatched and 90 are matched (or earlier, depending on other stopping conditions). | . | early_stop_un_t_frac | float | 0.1 | Must be between 0.0 and 1.0. This provides a fraction of unmatched treatment units. When the threshold is met, the algorithm will stop iterating. For example, using an input dataset with 100 treatment units, the algorithm will stop when 10 control units are unmatched and 90 are matched (or earlier, depending on other stopping conditions). | . | early_stop_pe | bool | False | If this is true, then if the covariate set chosen for matching has a predictive error higher than the parameter early_stop_pe_frac, the algorithm will stop. | . | early_stop_pe_frac | float | 0.01 | If early_stop_pe is true, then if the covariate set chosen for matching has a predictive error higher than this value, the algorithm will stop. | . | want_pe | bool | False | If true, the output of the algorithm will include the predictive error of the covariate sets used for matching in each iteration. | . | want_bf | bool | False | If true, the output will include the balancing factor for each iteration. | . | missing_indicator | {character, integer, numpy.nan} | numpy.nan | This is the indicator for missing data in the dataset. | . | missing_holdout_replace | int: {0,1,2} | 0 | If 0, assume no missing holdout training data and proceed. If 1, the algorithm excludes units with missing values from the holdout dataset. If 2, do MICE on holdout dataset. If this option is selected, it will be done for a number of iterations equal to missing_holdout_imputations. | . | missing_data_replace | int: {0,1,2,3} | 0 | If 0, assume no missing data in matching data and proceed. If 1, the algorithm does not match on units that have missing values. If 2, prevent all missing_indicator values from being matched on. If 3, do MICE on matching dataset. This is not recommended. If this option is selected, it will be done for a number of iterations equal to missing_data_imputations. | . | missing_holdout_imputations | int | 10 | If missing_holdout_replace=2, the number of imputations. | . | missing_data_imputations | int | 1 | If missing_data_replace=3, the number of imputations. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/DAME#parameters",
    "relUrl": "/api-documentation/DAME#parameters"
  },"6": {
    "doc": "DAME",
    "title": "Attributes",
    "content": "| Attribute Name | Type | Description | . | units_per_group | Array | This is an array of arrays. Each sub-array is a matched group, and each item in each sub-array is an int, indicating the unit in that matched group. If matching is done with repeats=False then no unit will appear more than once. If repeats=True then the first group in which a unit appears is its main matched group. | . | df_units_and_covars_matched | dataframe | This is the resulting matches of DAME. Each matched unit is in this array, and the covariates they were matched on have the value used to match. The covariates units were not matched on are indicated with a * | . | groups_per_unit | Array | The length of this is equal to the number of units in the input array. Each item in this array corresponds to the number of times that each item was matched. If matching is done with repeats=False, then this number will be either 0 or 1. | . | bf_each_iter | Array | if want_bf parameter is True, this will contain the balancing factor of the chosen covariate set at each iteration | . | pe_each_iter | Array | if want_pe parameter is True, this will contain the predictive error of the chosen covariate set at each iteration | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/DAME#attributes",
    "relUrl": "/api-documentation/DAME#attributes"
  },"7": {
    "doc": "DAME",
    "title": "Quick Example",
    "content": "import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.DAME() model.fit() result = model.predict() print(result) #&gt; x1 x2 x3 x4 #&gt; 0 * 1 1 1 #&gt; 1 * 1 1 * #&gt; 2 * * 1 1 #&gt; 3 * 1 1 1 . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/DAME#quick-example",
    "relUrl": "/api-documentation/DAME#quick-example"
  },"8": {
    "doc": "DAME",
    "title": "Methods",
    "content": "| fit(self, holdout_data, treatment_col....) | Provide self with holdout training data | . | predict(self, input_data...) | Perform the match on the input data | . __init__(adaptive_weights='ridge', alpha=0.1, repeats=True, verbose=2, early_stop_iterations=False, stop_unmatched_c=False, early_stop_un_c_frac=False, stop_unmatched_t=False, early_stop_un_t_frac=False, early_stop_pe=False, early_stop_pe_frac=0.01, missing_indicator=np.nan, missing_data_replace=0, missing_holdout_replace=0, missing_holdout_imputations=10, missing_data_imputations=1, want_pe=False, want_bf=False) . Source Code . Initialize self . fit(self, holdout_data=False, treatment_column_name='treated', outcome_column_name='outcome' weight_array=False)) . Source Code . Provide self with holdout training data . | fit Parameter Name | Type | Default | Description | . | holdout_data | {string, dataframe, float, False } | False | This is the holdout training dataset. If a string is given, that should be the location of a CSV file to input. If a float between 0.0 and 1.0 is given, that corresponds the percent of the input dataset to randomly select for holdout data. If False, the holdout data is equal to the entire input data. | . | treatment_column_name | string | “treated” | This is the name of the column with a binary indicator for whether a row is a treatment or control unit. | . | outcome_column_name | string | “outcome” | This is the name of the column with the outcome variable of each unit. | . | adaptive_weights | {bool, “ridge”, “decisiontree”, “ridgeCV”, “decisiontreeCV”} | “ridge” | The method used to decide what covariate set should be dropped next. | . | weight_array | array | optional | If adaptive_weights = False, these are the weights to the covariates in input_data, for the non-adaptive version of DAME. Must sum to 1. In this case, we do not use machine learning for the weights, they are manually entered as weight_array. | . predict(self, input_data) . Source Code . Perform match and return matches . | predict Parameter Name | Type | Default | Description | . | input_data | {string, dataframe} | Required Parameter | The dataframe on which to perform the matching, or the location of the CSV with the dataframe | . | predict Return | Description | . | Result | Pandas dataframe of matched units and covariates matched on, with a “*” at each covariate that a unit did not use in matching | . Further Readings . Liu, Dieng, et al. Interpretable Almost Matching Exactly For Causal Inference. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/DAME#methods",
    "relUrl": "/api-documentation/DAME#methods"
  },"9": {
    "doc": "DAME",
    "title": "DAME",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/DAME",
    "relUrl": "/api-documentation/DAME"
  },"10": {
    "doc": "FLAME",
    "title": "dame_flame.matching.FLAME",
    "content": "The FLAME algorithm class . class dame_flame.matching.FLAME(adaptive_weights='ridge', alpha=0.1, repeats=True, verbose=2, early_stop_iterations=False, stop_unmatched_c=False, early_stop_un_c_frac=False, stop_unmatched_t=False, early_stop_un_t_frac=False, early_stop_pe=False, early_stop_pe_frac=0.01, missing_indicator=np.nan, missing_data_replace=0, missing_holdout_replace=0, missing_holdout_imputations=10, missing_data_imputations=1, want_pe=False, want_bf=False) . Source Code . This class creates the matches based on the FLAME “Fast Large-Scale Almost Matching Exactly” algorithm. It has built in support for stopping criteria and missing data handling. Read more in the User Guide . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/FLAME#dame_flamematchingflame",
    "relUrl": "/api-documentation/FLAME#dame_flamematchingflame"
  },"11": {
    "doc": "FLAME",
    "title": "Parameters",
    "content": "| Parameter Name | Type | Default | Description | . | adaptive_weights | {bool, ‘ridge’, ‘decisiontree’, ‘ridgeCV’, ‘decisiontreeCV’} | ‘ridge’ | The method used to decide what covariate set should be dropped next. | . | alpha | float | 0.1 | If adaptive_weights is set to ridge, this is the alpha for ridge regression. | . | repeats | bool | True | Whether or not units for whom a main matched has been found can be used again, and placed in an auxiliary matched group. | . | verbose | int: {0,1,2,3} | 2 | Style of printout while algorithm runs. If 0, no output. If 1, provides iteration number. If 2, provides iteration number and additional information on the progress of the matching at every 10th iteration. If 3, provides iteration number and additional information on the progress of the matching at every iteration | . | early_stop_iterations | int | 0 | If provided, a number of iterations after which to hard stop the algorithm. | . | stop_unmatched_c | bool | False | If True, then the algorithm terminates when there are no more control units to match. | . | stop_unmatched_t | bool | False | If True, then the algorithm terminates when there are no more treatment units to match. | . | early_stop_un_c_frac | float | 0.1 | Must be between 0.0 and 1.0. This provides a fraction of unmatched control units. When the threshold is met, the algorithm will stop iterating. For example, using an input dataset with 100 control units, the algorithm will stop when 10 control units are unmatched and 90 are matched (or earlier, depending on other stopping conditions). | . | early_stop_un_t_frac | float | 0.1 | Must be between 0.0 and 1.0. This provides a fraction of unmatched treatment units. When the threshold is met, the algorithm will stop iterating. For example, using an input dataset with 100 treatment units, the algorithm will stop when 10 control units are unmatched and 90 are matched (or earlier, depending on other stopping conditions). | . | early_stop_pe | bool | False | If this is true, then if the covariate set chosen for matching has a predictive error higher than the parameter early_stop_pe_frac, the algorithm will stop. | . | early_stop_pe_frac | float | 0.01 | If early_stop_pe is true, then if the covariate set chosen for matching has a predictive error higher than this value, the algorithm will stop. | . | want_pe | bool | False | If true, the output of the algorithm will include the predictive error of the covariate sets used for matching in each iteration. | . | want_bf | bool | False | If true, the output will include the balancing factor for each iteration. | . | missing_indicator | {character, integer, numpy.nan} | numpy.nan | This is the indicator for missing data in the dataset. | . | missing_holdout_replace | int: {0,1,2} | 0 | If 0, assume no missing holdout data and proceed. If 1, the algorithm excludes units with missing values from the holdout dataset. If 2, do MICE on holdout dataset. If this option is selected, it will be done for a number of iterations equal to missing_holdout_imputations. | . | missing_data_replace | int: {0,1,2,3} | 0 | If 0, assume no missing data in matching data and proceed. If 1, the algorithm does not match on units that have missing values. If 2, prevent all missing_indicator values from being matched on. If 3, do MICE on matching dataset. This is not recommended. If this option is selected, it will be done for a number of iterations equal to missing_data_imputations. | . | missing_holdout_imputations | int | 10 | If missing_holdout_replace=2, the number of imputations. | . | missing_data_imputations | int | 1 | If missing_data_replace=3, the number of imputations. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/FLAME#parameters",
    "relUrl": "/api-documentation/FLAME#parameters"
  },"12": {
    "doc": "FLAME",
    "title": "Attributes",
    "content": "| Attribute Name | Type | Description | . | units_per_group | Array | This is an array of arrays. Each sub-array is a matched group, and each item in each sub-array is an int, indicating the unit in that matched group. If matching is done with repeats=False then no unit will appear more than once. If repeats=True then the first group in which a unit appears is its main matched group. | . | df_units_and_covars_matched | dataframe | This is the resulting matches of FLAME. Each matched unit is in this array, and the covariates they were matched on have the value used to match. The covariates units were not matched on are indicated with a * | . | groups_per_unit | Array | The length of this is equal to the number of units in the input array. Each item in this array corresponds to the number of times that each item was matched. If matching is done with repeats=False, then this number will be either 0 or 1. | . | bf_each_iter | Array | if want_bf parameter is True, this will contain the balancing factor of the chosen covariate set at each iteration | . | pe_each_iter | Array | if want_pe parameter is True, this will contain the predictive error of the chosen covariate set at each iteration | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/FLAME#attributes",
    "relUrl": "/api-documentation/FLAME#attributes"
  },"13": {
    "doc": "FLAME",
    "title": "Quick Example",
    "content": "import pandas as pd import dame_flame df = pd.read_csv(\"dame_flame/data/sample.csv\") model = dame_flame.matching.FLAME() model.fit(df) result = model.predict(df) print(result) #&gt; x1 x2 x3 x4 #&gt; 0 * 1 1 1 #&gt; 2 * * 1 1 #&gt; 3 * 0 1 1 . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/FLAME#quick-example",
    "relUrl": "/api-documentation/FLAME#quick-example"
  },"14": {
    "doc": "FLAME",
    "title": "Methods",
    "content": "| fit(self, holdout_data, treatment_col....) | Provide self with holdout training data | . | predict(self, input_data...) | Perform the match on the input data | . __init__(adaptive_weights='ridge', alpha=0.1, repeats=True, verbose=2, early_stop_iterations=False, stop_unmatched_c=False, early_stop_un_c_frac=False, stop_unmatched_t=False, early_stop_un_t_frac=False, early_stop_pe=False, early_stop_pe_frac=0.01 missing_indicator=np.nan, missing_data_replace=0, missing_holdout_replace=0, missing_holdout_imputations=10, missing_data_imputations=1, want_pe=False, want_bf=False) . Source Code . Initialize self . fit(self, holdout_data=False, treatment_column_name='treated', outcome_column_name='outcome' weight_array=False)) . Source Code . Provide self with holdout data . | fit Parameter Name | Type | Default | Description | . | holdout_data | {string, dataframe, float, False } | False | This is the holdout training dataset. If a string is given, that should be the location of a CSV file to input. If a float between 0.0 and 1.0 is given, that corresponds the percent of the input dataset to randomly select for holdout data. If False, the holdout data is equal to the entire input data. | . | treatment_column_name | string | “treated” | This is the name of the column with a binary indicator for whether a row is a treatment or control unit. | . | outcome_column_name | string | “outcome” | This is the name of the column with the outcome variable of each unit. | . | adaptive_weights | {bool, “ridge”, “decisiontree”, “ridgeCV”, “decisiontreeCV”} | “ridge” | The method used to decide what covariate set should be dropped next. | . | weight_array | array | optional | If adaptive_weights = False, these are the weights to the covariates in input_data, for the non-adaptive version of FLAME. Must sum to 1. In this case, we do not use machine learning for the weights, they are manually entered as weight_array. | . predict(self, input_data) . Source Code . Perform match and return matches . | predict Parameter Name | Type | Default | Description | . | input_data | {string, dataframe} | Required Parameter | The dataframe on which to perform the matching, or the location of the CSV with the dataframe | . | C | float | 0.1 | The tradeoff parameter between the balancing factor and the predictive error when deciding which covariates to match on | . | pre_dame | {bool, integer} | False | If an integer is provided, this is the number of iterations to run the FLAME algorithm for before switching to DAME, in order for a hybrid FLAME-DAME option. | . | predict Return | Description | . | Result | Pandas dataframe of matched units and covariates matched on, with a “*” at each covariate that a unit did not use in matching | . Further Readings . Wang, Morucci, et al. FLAME: A Fast Large-scale Almost Matching Exactly Approach to Causal Inference. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/FLAME#methods",
    "relUrl": "/api-documentation/FLAME#methods"
  },"15": {
    "doc": "FLAME",
    "title": "FLAME",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/FLAME",
    "relUrl": "/api-documentation/FLAME"
  },"16": {
    "doc": "ATE",
    "title": "dame_flame.utils.post_processing.ATE",
    "content": "The average treatment effect estimate of the data . ATE(matching_object) . Source Code . Uses the matches created by the FLAME and DAME algorithms to provide ATE of the dataset. Read more about Average Treatment Effect (ATE) in the User Guide . | Parameter Name | Type | Description | . | matching_object | {dame_flame.matching.DAME, dame_flame.matching.FLAME} | The matching object used to run DAME and FLAME. This must be after the .fit() and .predict() methods have been called to create the matches. | . | Return Name | Type | Description | . | ATE | {float, np.nan} | A float representing the ATE of the dataset. If no units were matched, then the output will be np.nan. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/ATE#dame_flameutilspost_processingate",
    "relUrl": "/api-documentation/post-processing/ATE#dame_flameutilspost_processingate"
  },"17": {
    "doc": "ATE",
    "title": "Quick Example",
    "content": "import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.DAME() model.fit(df) result = model.predict(df) ate = dame_flame.utils.post_processing.ATE(model) . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/ATE#quick-example",
    "relUrl": "/api-documentation/post-processing/ATE#quick-example"
  },"18": {
    "doc": "ATE",
    "title": "ATE",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/ATE",
    "relUrl": "/api-documentation/post-processing/ATE"
  },"19": {
    "doc": "ATT",
    "title": "dame_flame.utils.post_processing.ATT",
    "content": "The average treatment effect estimate on the treated units in the data . ATT(matching_object) . Source Code . Uses the matches created by the FLAME and DAME algorithms to provide ATT of the dataset. Read more about Average Treatment Effect on treated units (ATT) in the User Guide . | Parameter Name | Type | Description | . | matching_object | {dame_flame.matching.DAME, dame_flame.matching.FLAME} | The matching object used to run DAME and FLAME. This must be after the .fit() and .predict() methods have been called to create the matches. | . | Return Name | Type | Description | . | ATT | {float, np.nan} | A float representing the ATT of the dataset. If no units were matched, then the output will be np.nan. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/ATT#dame_flameutilspost_processingatt",
    "relUrl": "/api-documentation/post-processing/ATT#dame_flameutilspost_processingatt"
  },"20": {
    "doc": "ATT",
    "title": "Quick Example",
    "content": "import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.DAME() model.fit(df) result = model.predict(df) att = dame_flame.utils.post_processing.ATT(model) . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/ATT#quick-example",
    "relUrl": "/api-documentation/post-processing/ATT#quick-example"
  },"21": {
    "doc": "ATT",
    "title": "ATT",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/ATT",
    "relUrl": "/api-documentation/post-processing/ATT"
  },"22": {
    "doc": "CATE",
    "title": "dame_flame.utils.post_processing.CATE",
    "content": "The conditional average treatment effect estimate of a subset of the data . CATE(matching_object, unit_ids) . Source Code . Uses the matches created by the FLAME and DAME algorithms to provide CATE of subsets of the dataset. Read more about Conditional Average Treatment Effect (CATE) estimates in the User Guide . | Parameter Name | Type | Description | . | matching_object | {dame_flame.matching.DAME, dame_flame.matching.FLAME} | The matching object used to run DAME and FLAME, after the .fit() and .predict() methods have been called to create the matches. If the matching_object’s parameter for verbose is not 0, then as units without matches appear, the function will print this. | . | unit_ids | {int, list} | A unit id or list of unit ids | . | Return Name | Type | Description | . | MMGs | {list, float, np.nan} | If one unit id was provided, this is a single float representing the conditional average treatment effect of the unit. This is equal to the CATE of the group that the unit is in. If the unit does not have a match, the return will be np.nan. If multiple unit ids were provided, this will be a list of floats with the CATE of each unit provided. If any unit does not have a match, rather than a float within the list, at its place will be np.nan. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/CATE#dame_flameutilspost_processingcate",
    "relUrl": "/api-documentation/post-processing/CATE#dame_flameutilspost_processingcate"
  },"23": {
    "doc": "CATE",
    "title": "Quick Example",
    "content": "import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.DAME() model.fit(df) result = model.predict(df) cate = dame_flame.utils.post_processing.CATE(model, 0) . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/CATE#quick-example",
    "relUrl": "/api-documentation/post-processing/CATE#quick-example"
  },"24": {
    "doc": "CATE",
    "title": "CATE",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/CATE",
    "relUrl": "/api-documentation/post-processing/CATE"
  },"25": {
    "doc": "Matched Group",
    "title": "dame_flame.utils.post_processing.MG",
    "content": "The matched group of a unit . MG(matching_object, unit_ids, output_style=1) . Source Code . Uses the matches created by the FLAME and DAME algorithms to provide main matched groups of units. Read more about matched groups in the User Guide . | Parameter Name | Type | Description | . | matching_object | {dame_flame.matching.DAME, dame_flame.matching.FLAME} | The matching object used to run DAME and FLAME, after the .fit() and .predict() methods have been called to create the matches. If the matching_object’s parameter for verbose is not 0, then as units without matches appear, the function will print this. | . | unit_ids | {int, list} | A unit id or list of unit ids | . | output_style | int: {0,1} (default=1) | If 1, the covariates which were not used in matching for the group of the unit will have a “*” rather than the covariate value. Otherwise, it will output all covariate values. | . | Return Name | Type | Description | . | MMGs | {list, dataframe, np.nan} | If one unit id was provided, this is a single dataframe containing the main matched group of the unit. If the unit does not have a match, the return will be np.nan. If multiple unit ids were provided, this will be a list of dataframes with the main matched group of each unit provided. If any unit does not have a match, rather than a dataframe, at its place will be np.nan. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/matched-group#dame_flameutilspost_processingmg",
    "relUrl": "/api-documentation/post-processing/matched-group#dame_flameutilspost_processingmg"
  },"26": {
    "doc": "Matched Group",
    "title": "Quick Example",
    "content": "import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.DAME() model.fit(df) result = model.predict(df) mmg = dame_flame.utils.post_processing.MG(model, 0) . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/matched-group#quick-example",
    "relUrl": "/api-documentation/post-processing/matched-group#quick-example"
  },"27": {
    "doc": "Matched Group",
    "title": "Matched Group",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/matched-group",
    "relUrl": "/api-documentation/post-processing/matched-group"
  },"28": {
    "doc": "Post Processing",
    "title": "Post Processing",
    "content": "These functions generate treatment effects and matched groups after a match has been found using the matching algorithms. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/post-processing/",
    "relUrl": "/api-documentation/post-processing/"
  },"29": {
    "doc": "Data Generating",
    "title": "dame_flame.utils.data",
    "content": "Functions that generate data according to a distribution, returning the data and the true treatment effects of the values. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/data-generating/#dame_flameutilsdata",
    "relUrl": "/api-documentation/data-generating/#dame_flameutilsdata"
  },"30": {
    "doc": "Data Generating",
    "title": "dame_flame.utils.data.generate_uniform_given_importance",
    "content": "Creates a dataset with covariates in a uniform distribution where the covariates’ importance can be pre-specified by the user. The treatment effect will be normally distributed. generate_uniform_given_importance(num_control=1000, num_treated=1000, num_cov=4, min_val=0, max_val=3, covar_importance=[4, 3, 2, 1], bi_mean=2, bi_stdev=1) . Source Code . | Parameter Name | Type | Description | . | num_control | integer | The number of units in the control group | . | num_treated | integer | The number of units in the treated group | . | num_cov | integer | The number of covariates | . | min_val | integer | The minimum value each covariate can take | . | max_val | integer | The maximum value each covariate can take | . | covar_importance | array | The importance each covariate has in determining the outcome. Must be of length num_cov | . | bi_mean | numerical | The treatment effect is normally distributed with this mean | . | bi_stdev | numerical | The treatment effect is normally distributed with this standard deviation | . | Return Name | Type | Description | . | data_frame | Pandas Dataframe | A dataframe that is according to the specifications. Units 0 through num_treated are treatment group, and num_treated through num_treated+num_control are control group units. | . | true_catt | array | The CATE of each treated unit, where the ith has the treatment effect of the ith unit in the dataframe. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/data-generating/#dame_flameutilsdatagenerate_uniform_given_importance",
    "relUrl": "/api-documentation/data-generating/#dame_flameutilsdatagenerate_uniform_given_importance"
  },"31": {
    "doc": "Data Generating",
    "title": "dame_flame.utils.data.generate_binomial_given_importance",
    "content": "Creates a dataset with covariates in a binomial distribution where the covariates’ importance on outcome can be pre-specified by the user. The treatment effect will be normally distributed. generate_binomial_given_importance(num_control=1000, num_treated=1000, num_cov=5, bernoulli_param=0.5, bi_mean=2, bi_stdev=1, covar_importance=[4, 3, 2, 1, 0.01]) . Source Code . | Parameter Name | Type | Description | . | num_control | integer | The number of units in the control group | . | num_treated | integer | The number of units in the treated group | . | num_cov | integer | The number of covariates | . | bernoulli_param | numerical | The bernoulli parameter determining the distribution of the covariates | . | covar_importance | array | The importance each covariate has in determining the outcome. Must be of length num_cov | . | bi_mean | numerical | The treatment effect is normally distributed with this mean | . | bi_stdev | numerical | The treatment effect is normally distributed with this standard deviation | . | Return Name | Type | Description | . | data_frame | Pandas Dataframe | A dataframe that is according to the specifications. Units 0 through num_treated are treatment group, and num_treated through num_treated+num_control are control group units. | . | true_catt | array | The CATE of each treated unit, where the ith has the treatment effect of the ith unit in the dataframe. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/data-generating/#dame_flameutilsdatagenerate_binomial_given_importance",
    "relUrl": "/api-documentation/data-generating/#dame_flameutilsdatagenerate_binomial_given_importance"
  },"32": {
    "doc": "Data Generating",
    "title": "dame_flame.utils.data.generate_binomial_decay_importance",
    "content": "Creates a dataset with covariates in a binomial distribution where the covariates’ importance on outcome exponentially decays rather than being determined by the user. The treatment effect will be normally distributed. generate_binomial_decay_importance(num_control=1000, num_treated=1000, num_cov=5, bernoulli_param=0.5, bi_mean=2, bi_stdev=1) . Source Code . | Parameter Name | Type | Description | . | num_control | integer | The number of units in the control group | . | num_treated | integer | The number of units in the treated group | . | num_cov | integer | The number of covariates | . | bernoulli_param | numerical | The bernoulli parameter determining the distribution of the covariates | . | bi_mean | numerical | The treatment effect is normally distributed with this mean | . | bi_stdev | numerical | The treatment effect is normally distributed with this standard deviation | . | Return Name | Type | Description | . | data_frame | Pandas Dataframe | A dataframe that is according to the specifications. Units 0 through num_treated are treatment group, and num_treated through num_treated+num_control are control group units. | . | true_catt | array | The CATE of each treated unit, where the ith has the treatment effect of the ith unit in the dataframe. | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/data-generating/#dame_flameutilsdatagenerate_binomial_decay_importance",
    "relUrl": "/api-documentation/data-generating/#dame_flameutilsdatagenerate_binomial_decay_importance"
  },"33": {
    "doc": "Data Generating",
    "title": "Data Generating",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation/data-generating/",
    "relUrl": "/api-documentation/data-generating/"
  },"34": {
    "doc": "API Documentation",
    "title": "API Documentation",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/api-documentation",
    "relUrl": "/api-documentation"
  },"35": {
    "doc": "Benefit to Early Stopping",
    "title": "Early Stopping and Treatment Effect Estimates",
    "content": "Both the FLAME and DAME algorithms begin by matching any units that are exactly the same on all covariates in the dataset (“identical twins”). As iterations of the algorithm progress, later matched units are likely to have the highest error in estimated treatment effects. For this reason, there are situations where a user may wish to stop the FLAME or DAME algorithm in order to avoid poor quality matches, and if its not critical that all units are matched. From this example, we see that if high accuraccy between the estimated treatment effect and true treatment effect is a priority, then this algorithm should be stopped early. import numpy as np import pandas as pd import dame_flame import matplotlib.pyplot as plt from sklearn.metrics import mean_squared_error df, true_catt = dame_flame.utils.data.generate_binomial_decay_importance( num_control=1000, num_treated=1000, num_cov=10, bernoulli_param=0.5, bi_mean=2, bi_stdev=1) model = dame_flame.matching.DAME(repeats=False, verbose=0) model.fit(holdout_data=df) model.predict(df) model_stop_early = dame_flame.matching.DAME(repeats=False, verbose=0, early_stop_un_c_frac=0.3) model_stop_early.fit(holdout_data=df) model_stop_early.predict(df) estimated_catt_full = [] true_catt_full = [] estimated_catt_early = [] true_catt_early = [] for unit in range(len(df)): if df.loc[unit]['treated'] == 1: temp_cate = dame_flame.utils.post_processing.CATE(model, unit) if temp_cate is not np.nan: estimated_catt_full.append(temp_cate) true_catt_full.append(true_catt[unit]) temp_cate = dame_flame.utils.post_processing.CATE(model_stop_early, unit) if temp_cate is not np.nan: estimated_catt_early.append(temp_cate) true_catt_early.append(true_catt[unit]) f, axes = plt.subplots(1, 2, gridspec_kw = {'width_ratios':[1, 1]}, figsize=(12,9), sharey=True) def draw_scatter(ax, x, y, title, color, mse, yticks= False): ax.scatter(x, y, c = color, alpha = 0.3, marker = 'o', edgecolor = 'black') ax.set_title(title, pad = 0.2, wrap = True, fontsize=16) ax.tick_params() ax.set_ylabel(\"Estimated CATT\", fontsize=16) ax.text(3, 1, \"MSE: {:.2f}\".format(mse), ha='center', va='center') ax.set_xlabel('True CATT', fontsize=16) draw_scatter(axes[0], true_catt_early, estimated_catt_early, \"DAME, stopped at 30% control unmatched\", \"green\", mean_squared_error(true_catt_early, estimated_catt_early), True) draw_scatter(axes[1], true_catt_full, estimated_catt_full, \"DAME, matching all units\", \"green\", mean_squared_error(true_catt_full, estimated_catt_full), True) . Download Example From GitHub . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/early_stopping/#early-stopping-and-treatment-effect-estimates",
    "relUrl": "/examples/early_stopping/#early-stopping-and-treatment-effect-estimates"
  },"36": {
    "doc": "Benefit to Early Stopping",
    "title": "Benefit to Early Stopping",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/early_stopping/",
    "relUrl": "/examples/early_stopping/"
  },"37": {
    "doc": "Exact Matching Only",
    "title": "Exact Matching",
    "content": "The DAME or FLAME algorithm can be configured to be used for exact matching, using the early stopping criteria parameter early_stop_iterations=1. We illustrate this below. On a dataset with 200 units and five covariates that was generated with little randomness in which most covariate values are the same, we are only interested in exactly matched units. The output generated by the verbose=3 parameter shows that the majority of units are matched after one iteration. We visualize the treatment effect of each group, or the CATE of each group, using matplotlib [1]. We also visualize the matched groups’ sizes, which shows that one group has the majority of units. import dame_flame import matplotlib.pyplot as plt df,_ = dame_flame.utils.data.generate_binomial_decay_importance(num_control=100, num_treated=100, num_cov=5, bernoulli_param=0.9, bi_mean=2, bi_stdev=1) model = dame_flame.matching.FLAME(verbose=3, early_stop_iterations=1) model.fit(holdout_data=df) res = model.predict(df) groups = list(range(len(model.units_per_group))) cate_of_group = [] len_group = [] for group in model.units_per_group: cate_of_group.append(dame_flame.utils.post_processing.CATE(model, group[0])) len_group.append(len(group)) f, ax = plt.subplots(1, 2, gridspec_kw = {'width_ratios':[1, 1]}, figsize=(12,4)) ax[0].set_ylabel('Treatment Effect of Group', fontsize=14) ax[0].set_xlabel('Matched group ID number', fontsize=14) ax[0].set_title('Treatment Effect of Each Group of Perfectly Matched Units', fontsize=14) ax[0].bar(groups,cate_of_group) ax[1].set_ylabel('Number of Units in Group', fontsize=14) ax[1].set_xlabel('Matched group ID number', fontsize=14) ax[1].set_title('Size of Each Group of Perfectly Matched Units', fontsize=14) ax[1].bar(groups,len_group) plt.tight_layout() plt.savefig('treatment_effect_size_of_groups.png') . Download Example From GitHub . References . [1] Matplotlib: Grouped bar chart with labels ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/exact_matching/#exact-matching",
    "relUrl": "/examples/exact_matching/#exact-matching"
  },"38": {
    "doc": "Exact Matching Only",
    "title": "Exact Matching Only",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/exact_matching/",
    "relUrl": "/examples/exact_matching/"
  },"39": {
    "doc": "Examples",
    "title": "Examples",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples",
    "relUrl": "/examples"
  },"40": {
    "doc": "Comparing DAME and FLAME",
    "title": "Comparing Match Quality of DAME and FLAME",
    "content": "Both the FLAME and DAME algorithms begin by matching any possible identical twins (“exact matches”) in the dataset, meaning any units that have the same values on every possible covariate. As the FLAME algorithm progresses to match units that do not have identical twins, each subsequent iteration of the FLAME algorithm will attempt to match on one fewer covariate. So, suppose the total number of covariates in a dataset is $r$. After any units that can be exact matched on $r$ have been found, the next iteration of FLAME will attempt to match on $r-1$ covariates. In the next iteration, it improves upon the previous covariate set used for matching, and match on $r-2$ covariates. However, DAME will consider any covariate set options that will yield the highest-quality matches. The size of covariates matched on does not necessarily need to decrease over iterations of the algorithm. This one of the key advantages the DAME algorithm has over FLAME. DAME produces higher quality matches, meaning that more units are matched on a large number of covariates. We show this below using matplotlib [1], running the same dataset on FLAME and DAME for 10 iterations. import numpy as np import pandas as pd import dame_flame import matplotlib.pyplot as plt # Generate Data num_covariates = 10 df, true_catt = dame_flame.utils.data.generate_binomial_decay_importance(num_control=1000, num_treated=1000, num_cov=num_covariates, bernoulli_param=0.5, bi_mean=2, bi_stdev=1) # Get matches using DAME and FLAME model_dame = dame_flame.matching.DAME(repeats=False, verbose=0, early_stop_iterations=10) model_dame.fit(holdout_data=df) result_dame = model_dame.predict(df) model_flame = dame_flame.matching.FLAME(repeats=False, verbose=0, early_stop_iterations=10) model_flame.fit(holdout_data=df) result_flame = model_flame.predict(df) # replace all the '*'s with NAs so we can get a count of the NAs. result_flame = result_flame.replace(to_replace='*', value=np.nan) result_dame = result_dame.replace(to_replace='*', value=np.nan) # This will map: {number of covariates matched on : number of units matched on that number of covariates} dict_matched_result_dame = {k:0 for k in range(0,num_covariates+1)} dict_matched_result_flame = {k:0 for k in range(0,num_covariates+1)} # iterate through the rows in the df and count the number of non-NaN values in the row to determine # how many units that row was matched on. for i in result_flame.count(axis=1): dict_matched_result_flame[i] += 1 for i in result_dame.count(axis=1): dict_matched_result_dame[i] += 1 x = np.arange(len(dict_matched_result_flame.keys())) # the label locations width = 0.5 # the width of the bars # plot f, ax = plt.subplots(figsize=(12,9)) rects1 = ax.bar(x - width/2, dict_matched_result_flame.values(), width, color=\"green\", label = \"FLAME\" ) #, stopping at {}% control units matched\".format(percent), hatch=\"/\") rects2 = ax.bar(x + width/2, dict_matched_result_dame.values(), width, color = \"orange\", label = \"DAME\") #, stopping at {}% control units matched\".format(percent), hatch = \"\\\\\") ax.set_ylabel('Number of units', fontsize=16) ax.set_xlabel('Number of covariates matched on', fontsize=16) ax.set_title('Number of covariates that units were matched on after 10 iterations', fontsize=16) ax.set_xticks(x) ax.set_xticklabels(dict_matched_result_flame.keys()) ax.legend(fontsize=16) def autolabel(rects): \"\"\"Attach a text label above each bar in *rects*, displaying its height.\"\"\" for rect in rects: height = rect.get_height() ax.annotate('{}'.format(height), xy=(rect.get_x() + rect.get_width() / 2, height), xytext=(0, 3), # 3 points vertical offset textcoords=\"offset points\", ha='center', va='bottom') autolabel(rects1) autolabel(rects2) plt.savefig('flame_vs_dame_quality.png') . Download Example From GitHub . References . [1] Matplotlib: Grouped bar chart with labels ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/flame_vs_dame_quality/#comparing-match-quality-of-dame-and-flame",
    "relUrl": "/examples/flame_vs_dame_quality/#comparing-match-quality-of-dame-and-flame"
  },"41": {
    "doc": "Comparing DAME and FLAME",
    "title": "Comparing DAME and FLAME",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/flame_vs_dame_quality/",
    "relUrl": "/examples/flame_vs_dame_quality/"
  },"42": {
    "doc": "Interpreting Covariate Importance",
    "title": "Interpreting Covariate Importance",
    "content": "DAME-FLAME is an interpretable matching package because it allows users to quickly and easily understand which covariates were selected to be important to their outcome. This can be useful in determining who benefits from treatment the most and where resources should be spent for future treatment. In this example, using the verbose==3 option, we show how to view the iterations of the algorithm and infer the best covariates. We begin with a simulated dataset in which four covariates are labelled 0 to 3, and the covariates are of exponentially decreasing importance to the outcome as the label number increases. We see from the output that the FLAME algorithm drops unimportant covariates earlier in its algorithm. At each iteration of the FLAME algorithm, FLAME drops the least important covariate. In this example, we also graph the number of units that were placed in a matched group based on each covariate. You can see that most units were matched using the most important covariate, and the least important covariate is used in comparatively fewer matches. import dame_flame import numpy as np import matplotlib.pyplot as plt df,_ = dame_flame.utils.data.generate_binomial_decay_importance(50,50) model = dame_flame.matching.FLAME(verbose=3, repeats=False) model.fit(holdout_data=df) result_flame = model.predict(df) . # Get matches using DAME and FLAME model_dame = dame_flame.matching.DAME(repeats=False) model_dame.fit(holdout_data=df) result_dame = model_dame.predict(df) # replace all the '*'s with NAs so we can get a count of the NAs. result_flame = result_flame.replace(to_replace='*', value=np.nan) result_dame = result_dame.replace(to_replace='*', value=np.nan) # rename columns for graph X_columns = [\"X\" + col for col in result_flame.columns] result_flame.columns = X_columns result_dame.columns = X_columns x = np.arange(len(result_flame.columns)) # the label locations width = 0.35 # the width of the bars f, ax = plt.subplots(figsize=(12,9)) rects1 = ax.bar(x - width/2, result_dame.count(axis=0), width, color=\"lightcoral\", label = \"DAME\" ) #, stopping at {}% control units matched\".format(percent), hatch=\"/\") rects2 = ax.bar(x + width/2, result_flame.count(axis=0), width, color = \"darkorchid\", label = \"FLAME\") #, stopping at {}% control units matched\".format(percent), hatch = \"\\\\\") ax.set_ylabel('Number of units matched on covariate', fontsize=16) ax.set_xlabel('Covariate name', fontsize=16) ax.set_title('Covariate Importance, measured by number of units matched on each covariate', fontsize=16) ax.set_xticks(x) ax.set_xticklabels(result_flame.columns) ax.legend(fontsize=16) def autolabel(rects): \"\"\"Attach a text label above each bar in *rects*, displaying its height.\"\"\" for rect in rects: height = rect.get_height() ax.annotate('{}'.format(height), xy=(rect.get_x() + rect.get_width() / 2, height), xytext=(0, 3), # 3 points vertical offset textcoords=\"offset points\", ha='center', va='bottom') autolabel(rects1) autolabel(rects2) f.tight_layout() plt.savefig('interpretability.png') . Download Example From GitHub . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/interpretability/",
    "relUrl": "/examples/interpretability/"
  },"43": {
    "doc": "Natality Experiment",
    "title": "Experiment on Natality Dataset",
    "content": "In the linked Github file, we aim to examine the effect of “extreme smoking” of a mother during pregancy on her newborn’s birthweight. Overall, the results of the DAME-FLAME package lead us to believe that smoking during pregnancy causes significantly lower birthweight of infants. It also leads us to believe that there is little to no heterogeneity in conditional treatment effects of a mother’s smoking on birthweight. In other words, when we examine groupings of characteristics of mothers and infants (including race, gender of infant, etc), then we don’t see evidence that there exists some mothers and infants for whom the impact of maternal smoking on infant birthweight is different than the outcomes for other types of mothers and infants. We use the 2010 US Natality dataset from the National Vital Statistics System of the National Center for Health Statistics (2010). The accompanying user guide to the dataset is also linked with that URL, labelled “documentation”. Similar analysis is done in Wang, et al (2020). Notable differences between the two are that this experiment uses a smaller dataset and a slightly modified algorithm. This experiment aims to build upon the analysis on maternal smoking and infant birthweight shown in Kondracki (2020). Four key takeaways from the experiment on github: . | A common question about the dame-flame package is the discrete observational data requirement. This experiment uses data that is discrete, such as day of week, and total birth order. It also uses data that is binned continuous data, such as father’s age, which has been binned into fixed width intervals of five year age groups (15-19 years, 20-24 years, etc.). Mother’s education is also binned into bins with the completion of a degree, not the number of days of school attended. Both of these variables are binned in a way that is commonly done within research using this dataset, or similar datasets. | The covariate dropping order, shown above using the verbose=3 parameter, is something we use to interpret covariate importance. The FLAME algorithm learns the importance of each covariate on the outcome when choosing the best covariate to drop. Thus, the earlier dropped covariates can be considered less relevant to the outcome. In this case, FLAME would lead us to believe that some factors, such as mother’s education and the day of the week of the infant birth, are less predictive of an infant’s birth weight than other factors, such as the sex of the infant. | The ATE is highly negative. This leads us to believe that maternal extreme smoking causes an infant’s birthweight to be lower than not smoking by several grams. | Lastly, the plot as shown below, of CATE of matched groups against matched group size, leads us to believe there is little heterogeneity in the Conditional Average Treatment Effect (CATE) of maternal smoking on infant birth weight. Most extreme values are observed in small matched groups, for which CATE estimation is difficult. Put simply, we don’t see evidence that there exists some “types of” mothers and infants (classified by characteristics such as education and race) for whom the impact of maternal smoking on infant birthweight is different than the outcomes for other mothers and infants. | . Download Example From GitHub . References . [1] NCHS' Vital Statistics Natality Birth Data. [2] Wang, Morucci, et al. FLAME: A Fast Large-scale Almost Matching Exactly Approach to Causal Inference. [3] Kondracki, Anthony J. \"Low birthweight in term singletons mediates the association between maternal smoking intensity exposure status and immediate neonatal intensive care unit admission: the E-value assessment.\" BMC Pregnancy and Childbirth 20 (2020): 1-9.. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/natality_experiment/#experiment-on-natality-dataset",
    "relUrl": "/examples/natality_experiment/#experiment-on-natality-dataset"
  },"44": {
    "doc": "Natality Experiment",
    "title": "Natality Experiment",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/examples/natality_experiment/",
    "relUrl": "/examples/natality_experiment/"
  },"45": {
    "doc": "Contributing Guide",
    "title": "Contributing Guide",
    "content": "Thank you for considering contributing to dame-flame. Contributions are welcome from first time or advanced users, as are stories of use cases. There are many ways to contribute to the package. We welcome contributers who wish to report any unexpected bugs, clean or maintain code, add details or use cases to the documentation, and add more test cases. A commonly requested feature request or pull request will ask for a new learning algorithm. Any learning algorithm can be used to predict covariate importance, beyond the ones we have chosen to incorporate, which were chosen based on our impression of the most valuable algorithms. Additional algorithms can easily be added, using standard off-the-shelf methods, as a new feature. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/contributing_guide/",
    "relUrl": "/getting-started/contributing_guide/"
  },"46": {
    "doc": "Contributing Guide",
    "title": "Submitting Bug Reports or Feature Requests",
    "content": "Please open an issue on Github here: https://github.com/almost-matching-exactly/DAME-FlAME-Python-Package/issues/ . If this is a bug request, we ask that you describe the issue in as much detail as possible, including a description of expected results and experienced results. An example including datasets if possible could also be helpful. This is because reproducing an issue is critical to fixing it. If this is a feature request, we ask that you describe your use case and link any relevant references, in order for us to ensure that our features will meet your needs. You can also email our team to discuss if that is easier for you. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/contributing_guide/#submitting-bug-reports-or-feature-requests",
    "relUrl": "/getting-started/contributing_guide/#submitting-bug-reports-or-feature-requests"
  },"47": {
    "doc": "Contributing Guide",
    "title": "Contributing Code",
    "content": "Please contribute to the code using standard open source protocol on GitHub. In brief, after forking the repository on github, edit your files locally (We prefer to use the Sypder IDE for this), commit changes to your fork, and submit a pull request with a detailed explanation of your contributions. Below are some tips that will ensure your pull request is approved smoothly, with minimal requests for changes: . | Make sure your code passes the tests to ensure algorithm correctness in the /tests/ folder. Do this by running the following command from your terminal in the package repository: | . pytest . , or by checking to see if your pull request has passed checks run automatically by our Continuous Integration API, Travis-CI. | Ensure that your code meets our style guide standards for readability. We mostly adhere to the Google Python Style Gude, found here. | Ensure that your code meets our maintainability standards. We aim to ensure highly modularized, short code that is easy to use, debug, and maintain. If you can refactor anything, do it. | Write a test for your code, in order to ensure that the code coverage percentage remains high. We check coverage using the coveralls API. | Write an example illustrating your code, and update the documentation accordingly. The documentation is found in the ‘docs’ folder of the Github here: https://github.com/almost-matching-exactly/DAME-FLAME-Python-Package. We recommend using Visual Studio Code. The documentation can be compiled and previewed using the command: . | . bundle exec jekyll serve . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/contributing_guide/#contributing-code",
    "relUrl": "/getting-started/contributing_guide/#contributing-code"
  },"48": {
    "doc": "Contributing Guide",
    "title": "Questions",
    "content": "If you have any questions, or need assistance getting set up with a contribution, please reach out to our team. You can ask on GitHub’s issue tracker here, or contact neha.r.gupta “at” duke “dot” edu. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/contributing_guide/#questions",
    "relUrl": "/getting-started/contributing_guide/#questions"
  },"49": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started",
    "relUrl": "/getting-started"
  },"50": {
    "doc": "Installation and Quickstart Example",
    "title": "Installation and Quickstart Example",
    "content": ". | Dependencies | Installation | Quickstart Example | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/installation_example/",
    "relUrl": "/getting-started/installation_example/"
  },"51": {
    "doc": "Installation and Quickstart Example",
    "title": "Dependencies",
    "content": "This package requires prior installation of . | Python (&gt;= 3.0) | NumPy (&gt;= 1.17.5) | Scikit-Learn (&gt;= 0.22.1)) | Pandas (todo: check) | . If your computer system does not have python 3.*, install from here. If your python version does not have the Pandas, Scikit learn, or Numpy packages, install from here . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/installation_example/#dependencies",
    "relUrl": "/getting-started/installation_example/#dependencies"
  },"52": {
    "doc": "Installation and Quickstart Example",
    "title": "Installation",
    "content": "The DAME-FLAME Python Package is available for download on the almost-matching-exactly Github or via PyPi (recommended): . pip install dame-flame . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/installation_example/#installation",
    "relUrl": "/getting-started/installation_example/#installation"
  },"53": {
    "doc": "Installation and Quickstart Example",
    "title": "Quickstart Example",
    "content": "We run the DAME function with the following basic command. In this example, we provide only the basic inputs: (1) input data as a dataframe or file, (2) the name of the outcome column, and (3) the name of the treatment column. import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) print(df.head()) #&gt; x1 x2 x3 x4 treated outcome #&gt; 0 0 1 1 1 0 5 #&gt; 1 0 1 1 0 0 6 #&gt; 2 1 0 1 1 1 7 #&gt; 3 1 1 1 1 1 7 model = dame_flame.matching.DAME() model.fit(df) result = model.predict(df) print(result) #&gt; x1 x2 x3 x4 #&gt; 0 * 1 1 1 #&gt; 1 * 1 1 * #&gt; 2 * * 1 1 #&gt; 3 * 1 1 1 print(model.groups_per_unit) #&gt; 0 3.0 #&gt; 1 1.0 #&gt; 2 1.0 #&gt; 3 3.0 print(model.units_per_group) #&gt; [[0, 3], [0, 2, 3], [0, 1, 3]] . result is type Data Frame. The dataframe contains all of the units that were matched, and the covariates and corresponding values, that it was matched on. The covariates that each unit was not matched on is denoted with a “ * “ character. model.groups_per_unit is a Data Frame with a column of unit weights which specifies the number of groups that each unit was placed in. model.units_per_group is a list in which each list is a main matched group, and the unit ids that belong to that group. Additional values based on additional optional parameters can be retrieved, detailed in additional documentation below. To find the main matched group of a particular unit or group of units after DAME has been run, use the function MG: . mmg = dame_flame.utils.post_processing.MG(matching_object=model, unit_ids=0) print(mmg) #&gt; x1 x2 x3 x4 treated outcome #&gt; 0 * 1 1 1 0 5 #&gt; 3 * 1 1 1 1 7 . To find the conditional treatment effect (CATE) for the main matched group of a particular unit or group of units, use the function CATE: . cate = dame_flame.utils.post_processing.CATE(matching_object=model, unit_ids=0) print(cate) #&gt; 2.0 . To find the average treatment effect (ATE) or average treatment effect on the treated (ATT), use the functions ATE and ATT, respectively: . ate = dame_flame.utils.post_processing.ATE(matching_object=model) print(ate) #&gt; 1.825 att = dame_flame.utils.post_processing.ATT(matching_object=model) print(att) #&gt; 1.75 . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/getting-started/installation_example/#quickstart-example",
    "relUrl": "/getting-started/installation_example/#quickstart-example"
  },"54": {
    "doc": "Home",
    "title": "Welcome to the DAME-FLAME Python Package Documentation!",
    "content": "View us on GitHub View us on PyPi . dame-flame is a Python package for performing matching for observational causal inference on datasets containing discrete covariates. It implements the Dynamic Almost Matching Exactly (DAME) and Fast, Large-Scale Almost Matching Exactly (FLAME) algorithms, which match treatment and control units on subsets of the covariates. The resulting matched groups are interpretable, because the matches are made on covariates, and high-quality, because machine learning is used to determine which covariates are important to match on. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/#welcome-to-the-dame-flame-python-package-documentation",
    "relUrl": "/#welcome-to-the-dame-flame-python-package-documentation"
  },"55": {
    "doc": "Home",
    "title": "Contact",
    "content": "Please reach out to let our team know if you’re using this, or if you have any questions. You are welcome to contact Neha Gupta at neha.r.gupta@duke.edu. We also check public comments or questions posted on GitHub. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/#contact",
    "relUrl": "/#contact"
  },"56": {
    "doc": "Home",
    "title": "Home",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/",
    "relUrl": "/"
  },"57": {
    "doc": "Algorithm Controls",
    "title": "Early Stopping Controls",
    "content": ". | Introduction to Early Stopping Controls | Recommendations | . This goes in the Algorithm Controls page. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Algorithm-Controls#early-stopping-controls",
    "relUrl": "/user-guide/Algorithm-Controls#early-stopping-controls"
  },"58": {
    "doc": "Algorithm Controls",
    "title": "Introduction to Early Stopping Controls",
    "content": "The ideal situation for matching in causal inference is if each treatment unit has an exactly identical control unit. We can best determine the rise in income that a person experiences after a job training program if that person has an identical twin with the same degree and GPA as them who didn’t attend the job training program. The FLAME-DAME package begins by matching identical twins (“exact matches”) in the dataset. Since not all units have exact matches, most units are matched based on subsets of all covariates. The subset that a unit is matched on is the subsets that is selected to be most predictive of their outcome. As the FLAME and DAME algorithms run, the units that are matched later in the algorithm, are those that are most distinct in observable characteristics from the other units in the dataset are matched later. Later matched units are likely to have the highest error in estimated treatment effects. For this reason, there are situations where the FLAME or DAME algorithm should be stopped early in order to avoid poor matches. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Algorithm-Controls#introduction-to-early-stopping-controls",
    "relUrl": "/user-guide/Algorithm-Controls#introduction-to-early-stopping-controls"
  },"59": {
    "doc": "Algorithm Controls",
    "title": "Recommendations",
    "content": "The default option is that the algorithm runs until all units are matched. However, if runtime or high accuracy of estimates of treatment effects are important, then we recommend users experiment with their stopping criteria based on their specific need and dataset size. A large dataset will have a longer runtime, and an early stop will take less time. Regardless of the early stopping criteria chosen, in the majority of datasets, any early stopping will lead to closer estimates between the estimated and true treatment effects. This is illustrated in the examples section. If it is crucial that all units be matched, it is recommended that users do not use any early stopping criteria. | Category of Early Stopping | Technical Details | Usage Recommendation | Algorithm parameters | . | Algorithm Iterations | This provides a number of iterations after which to stop the DAME or FLAME algorithm. If FLAME is used, then this is the maximum number of covariates that can be dropped, meaning when the total number of covariates is $m$, no unit will be matched on $m-$early_stop_iterations covariates | This is useful in the case of a FLAME user knowing their preferred covariate match size, or if a user knows what runtime is sufficient from a previous experiment | early_stop_iterations | . | Unmatched Units in Treatment or Control | When the algorithm is set with the repeats=True parameter, then previously matched units can still be placed in groups with other units. The algorithm will by default stop iterating when there are no more units that have not been placed in any group. However, a case could arise where all units remaining to be placed in a group are of the treatment or control group, and we provide this option in case a user has preference between ensuring that all treated or control units are matched. | These parameters will not be useful, and is therefore not recommended in the case where the the repeats parameter is False. If repeats=False, then in effect, both of these parameters are True. | stop_unmatched_c, stop_unmatched_t | . | Proportion of unmatched units | This stops the algorithm when some fraction of control units or treatment units are unmatched | One specific case in which this could be useful immediately is where a user is certain that some percent of the input is unlikely to result in good matches. | early_stop_un_c_frac, early_stop_un_t_frac | . | Predictive Error | The predictive error measures how important a covariate set is for predicting the outcome on the holdout training dataset, using a machine learning algorithm. It is the sole determinant of the covariate set to match on for DAME, and one of two factors for FLAME. | The range of this value is specific to a dataset’s values. Therefore, reasonable values for this can only be determined after at least one prior run of this algorithm on the same dataset in which the predictive error is observed. | early_stop_pe, early_stop_pe_frac | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Algorithm-Controls#recommendations",
    "relUrl": "/user-guide/Algorithm-Controls#recommendations"
  },"60": {
    "doc": "Algorithm Controls",
    "title": "Algorithm Controls",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Algorithm-Controls",
    "relUrl": "/user-guide/Algorithm-Controls"
  },"61": {
    "doc": "Getting Matches",
    "title": "Getting Matches from the Data",
    "content": ". | FLAME | DAME | Hybrid FLAME-DAME | Variations in the learning of the best covariate set | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/Getting-Matches#getting-matches-from-the-data",
    "relUrl": "/documentation/user-guide/Getting-Matches#getting-matches-from-the-data"
  },"62": {
    "doc": "Getting Matches",
    "title": "FLAME",
    "content": "FLAME stands for Fast Large Scale Almost Matching Exactly. The FLAME algorithm begins by matching any units that can be matched exactly on all covariates. The algorithm will iterate over all covariates until stopping criteria is reached. In each iteration, the algorithm will drop the worst covariate set to match on, and units that have identical values in all of the remaining covariates will form a matched group. When deciding which covariate should be dropped, at each step, it drops the covariate leading to the smallest drop in match quality, MQ, defined as MQ=C·BF−PE. Here, PE denotes the predictive error, which measures how important the dropped covariate is for predicting the outcome on the holdout training dataset, using a machine learning algorithm. The balancing factor, BF, measures the number of matches formed by dropping that covariate and the discrepancy between the number of treated and control units after the matching. In future iterations, the covariate that was determined worst and was just dropped will not reappear, so the maximum number of times the algorithm will iterate is equal to the number of covariates. For more details on this algorithm, see [1]. import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"])model = dame_flame.matching.FLAME() model.fit(df) result = model.predict(df) print(result) #&gt; x1 x2 x3 x4 #&gt; 0 * 1 1 1 #&gt; 2 * * 1 1 #&gt; 3 * 0 1 1 . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/Getting-Matches#flame",
    "relUrl": "/documentation/user-guide/Getting-Matches#flame"
  },"63": {
    "doc": "Getting Matches",
    "title": "DAME",
    "content": "DAME stands for Dynamic Almost Matching Exactly. The algorithm begins by matching any units that can be matched exactly on all co-variates. The algorithm will iterate over options of covariates to match on until stopping criteria is reached. In each iteration, the algorithm will select the best covariate set to match on, and units that have identical values in all of the covariates that are part of the chosen covariate set will form a matched group. In its options of covariate sets to drop, DAME will always include the largest possible covariate sets, and will ultimately consider several combinations of covariates before selecting one to match on. It defines the best covariate set as the one that minimizes PE. PE is predictive error, and measures how important the covariate set is for predicting the outcome on the holdout training dataset, using a machine learning algorithm. For more details on this algorithm, see [2]. import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.DAME() model.fit(df) result = model.predict(df) print(result) #&gt; x1 x2 x3 x4 #&gt; 0 * 1 1 1 #&gt; 1 * 1 1 * #&gt; 2 * * 1 1 #&gt; 3 * 1 1 1 . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/Getting-Matches#dame",
    "relUrl": "/documentation/user-guide/Getting-Matches#dame"
  },"64": {
    "doc": "Getting Matches",
    "title": "Hybrid FLAME-DAME",
    "content": "The hybrid algorithm takes advantage of the speed of FLAME by quickly eliminating irrelevant covariates, and then switches to DAME to match remaining units on remaining covariates. import pandas as pd import dame_flame df = pd.DataFrame([[0,1,1,1,0,5], [0,1,1,0,0,6], [1,0,1,1,1,7], [1,1,1,1,1,7]], columns=[\"x1\", \"x2\", \"x3\", \"x4\", \"treated\", \"outcome\"]) model = dame_flame.matching.FLAME() model.fit(df) result = model.predict(df, pre_dame=1) print(result) #&gt; x1 x2 x3 x4 #&gt; 0 * 1 1 1 #&gt; 1 * 1 1 1 #&gt; 2 np.nan 1 1 * #&gt; 3 np.nan * 1 1 . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/Getting-Matches#hybrid-flame-dame",
    "relUrl": "/documentation/user-guide/Getting-Matches#hybrid-flame-dame"
  },"65": {
    "doc": "Getting Matches",
    "title": "Variations in the learning of the best covariate set",
    "content": "Both the FLAME and DAME algorithms choose the best covariate set after measuring how important each covariate set is for predicting the outcome on the holdout training dataset, using a machine learning algorithm. We offer different options for the machine learning algorithm used, as well as a simplified FLAME and simplified DAME that does not use machine learning. We use scikit-learn for the underlying learning algorithms, so we refer you to their documentation and references to learn more about these popular machine learning algorithms, as well as their specific implementations. For examples of categorical, binary, and numerical data, see [3]. | Learning Method | Technical Details | Usage Recommendation | Algorithm parameter | . | Ridge Regression | A ridge regression is similar to an ordinary least squares regression, but it imposes a penalty on the size of coefficients. It minimizes a residual sum of squares. A shrinkage parameter, $\\alpha$ must be included. We use an implementation provided by scikit-learn [4]. | This can only be used when it is certain that none of the covariates are categorical. Ordinal, binary, and discrete numerical data is all accepted. For this option, a larger $\\alpha$ corresponds should be chosen if it is believed that there is greater multicollinearity in the data, meaning that many covariates are linearly correlated. | adaptive_weights='ridge' | . | Ridge Regression CV | This is a ridge regression with built-in cross validation to determine the best $\\alpha$ parameter. We use the scikit-learn ridgeCV class, but the default array of $\\alpha$ options that we provide the function to iterate over is larger than the default they provide, for greater flexibility [5]. | This also can only be used when it is certain that none of the covariates are categorical. Ordinal, binary and discrete numerical data is all accepted. This option is advantageous over the ‘ridge’ option without cross validation in a case where a user is uncertain about the $\\alpha$ parameter, and a minor speed decrease from cross validation is acceptable. | adaptive_weights='ridgeCV' | . | Decision Tree | The underlying implementation is the Decision Tree Regression provided by scikit-learn, which uses a variation of CART [6]. Trees predict the value of the outcome by learning decision rules from the covariates. | This can be used for categorical, ordinal, binary, and discrete numerical data. Overfitting is a risk with decision tree models, which can be possible in DAME or FLAME algorithm if the holdout training and input datasets provided are the same. | adaptive_weights='decision-tree' | . References . [1] Wang, Morucci, et al. FLAME: A Fast Large-scale Almost Matching Exactly Approach to Causal Inference. [2] Liu, Dieng, et al. Interpretable Almost Matching Exactly For Causal Inference. [3] What is the Difference Between Categorical, Ordinal, and Numerical Variables? UCLA: Statistical Consulting Group. [4] Scikit-learn Ridge Regressions [5] Scikit-learn RidgeCV [6] Scikit-learn DecisionTree ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/Getting-Matches#variations-in-the-learning-of-the-best-covariate-set",
    "relUrl": "/documentation/user-guide/Getting-Matches#variations-in-the-learning-of-the-best-covariate-set"
  },"66": {
    "doc": "Getting Matches",
    "title": "Getting Matches",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/Getting-Matches",
    "relUrl": "/documentation/user-guide/Getting-Matches"
  },"67": {
    "doc": "Discrete Observation Requirement",
    "title": "DAME-FLAME Data Requirements",
    "content": ". | Discrete Observation Requirement for DAME-FLAME | Example of Acceptable Binning | Example using Binned Data | Input Format Example | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/data-requirements#dame-flame-data-requirements",
    "relUrl": "/documentation/user-guide/data-requirements#dame-flame-data-requirements"
  },"68": {
    "doc": "Discrete Observation Requirement",
    "title": "Discrete Observation Requirement for DAME-FLAME",
    "content": "The main requirements for researchers to justify the use of matching methods also hold for DAME-FLAME. Those are discussed here. In sum, we require SUTVA, ignorability, and some overlap. Additionally, we require that all observational covariates be discrete. The outcome data can be continuous. The treatment indicator column must be binary. We do not recommend users bin continous covariates. The exception that could be made is a scenario where users are confident they are binning variables in a way that is a typical for their research. In this scenario, categories must be pre-defined and considered acceptable in their domain of work. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/data-requirements#discrete-observation-requirement-for-dame-flame",
    "relUrl": "/documentation/user-guide/data-requirements#discrete-observation-requirement-for-dame-flame"
  },"69": {
    "doc": "Discrete Observation Requirement",
    "title": "Example of Acceptable Binning",
    "content": "In research incorporating infant births, gestation time could be binned and used in DAME-FLAME as an observational covariate. Classifications of gestational age are well established norms adhered to in obstetric publications. Early term is considered 37 0/7 weeks of gestation through 38 6/7 weeks of gestation, full term is 39 0/7 weeks of gestation through 40 6/7 weeks of gestation, etc. The American College of Obstetricians and Gynecologists and the Society for Maternal-Fetal Medicine endorse and encourage these categories [1]. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/data-requirements#example-of-acceptable-binning",
    "relUrl": "/documentation/user-guide/data-requirements#example-of-acceptable-binning"
  },"70": {
    "doc": "Discrete Observation Requirement",
    "title": "Example using Binned Data",
    "content": "This documentation provides an example here, where we aim to examine the effect of “extreme smoking” of a mother during pregancy on her newborn’s birthweight. We discuss using two binned continuous variables, father’s age, and mother’s education attainment. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/data-requirements#example-using-binned-data",
    "relUrl": "/documentation/user-guide/data-requirements#example-using-binned-data"
  },"71": {
    "doc": "Discrete Observation Requirement",
    "title": "Input Format Example",
    "content": "Below, we provide an example of the format that the DAME-FLAME package requires input data to be in. The input data can be either a file, or a Python Pandas Data Frame. All covariates in the input data should be categorical covariates. If there are continuous covariates, we only recommend users regroup the data if they are sure they are doing so in a way that is typical of their research question. In addition to input observational data columns, the input data must contain (1) A column indicating the outcome variable as an integer or float data type, and (2) A column specifying whether a unit is treated or control (treated = 1, control = 0) as an integer data type. There are no requirements for input data column names or order of columns. Below is an example of input data with n units and m covariates. | Column-name / unit-id | x_1 | x_2 | … | x_m | outcome | treated | . | 1 | 2 | 3 | … | 4 | 9 | 0 | . | 2 | 1 | 3 | … | 3 | 5.5 | 1 | . | 3 | 1 | 4 | … | 5 | -1 | 0 | . | … | … | … | … | … | … | … | . | n | 0 | 5 | … | 0 | 1 | 1 | . | Data Type | integer | integer | integer | integer | numeric | 0 or 1 | . The holdout training set, if provided, should also follow the same format. References . [1] ACOG Committee Opinion No 579: Definition of Term Pregnancy ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/data-requirements#input-format-example",
    "relUrl": "/documentation/user-guide/data-requirements#input-format-example"
  },"72": {
    "doc": "Discrete Observation Requirement",
    "title": "Discrete Observation Requirement",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/documentation/user-guide/data-requirements",
    "relUrl": "/documentation/user-guide/data-requirements"
  },"73": {
    "doc": "Introduction to Causal Inference",
    "title": "Introduction",
    "content": ". | Introduction to Causal Inference | Introduction to Matching | Challenges in Matching Methods | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Introduction#introduction",
    "relUrl": "/user-guide/Introduction#introduction"
  },"74": {
    "doc": "Introduction to Causal Inference",
    "title": "Introduction to Causal Inference",
    "content": "Causal inference is the attempt to draw conclusions that something is being caused by something else. It goes beyond questions of correlation, association, and is distinct from model-based predictive analysis. Questions of robust causal inference are practically unavoidable in health, medicine, or social studies. Much of the available data in the clinical and social sciences is observational, and we can only observe one outcome per individual. For example, if one individual took pain reliever for a headache and they now feel better, we don’t know what would have happened to that same individual over the same time period, if they had not taken pain reliever. Taking the pain reliever puts them in the treatment group, but since we don’t know what the control outcome of not taking pain reliever would be (without time travel), how can we say pain reliever caused the headache to go away? . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Introduction",
    "relUrl": "/user-guide/Introduction"
  },"75": {
    "doc": "Introduction to Causal Inference",
    "title": "Introduction to Matching",
    "content": "When estimating causal effects in an observational setting, one common approach is to match each treatment unit to an identical control unit. Going back to the example, can we find two people sharing every physical attribute, who also had the exact same symptoms, prior to the time when only one of them taking the pain reliever? Secondly, how did their outcomes differ? . In large datasets where we observe many characteristics about individuals, few “identical twins”, (referred to as “exact matches”) exist. What is the best way to match individuals that were treated and controlled? Only once they’re matched are we able to apply common treatment effect estimators to the groups of matched individuals, in order to try to determine the effect of treatment. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Introduction#introduction-to-matching",
    "relUrl": "/user-guide/Introduction#introduction-to-matching"
  },"76": {
    "doc": "Introduction to Causal Inference",
    "title": "Challenges in Matching Methods",
    "content": "“Exact matching” isn’t possible when we a dataset has lots of characteristics about individuals, or is high dimensional. So, matching methods performing the best-possible alternative should be interpretable. Users of matching algorithms need to be able to easily understand which covariates were selected to be most important to their outcome, and need be able to find out why they were selected. This is important so that causal analysis can provide crucial information on who benefits from treatment most, where resources should be spent for future treatments, and why some individuals benefit from treatment while others were not. This can also help researchers determine what type of additional data must be collected. Secondly, the matches should also be high quality. If an oracle could tell us the exact result of doing treatment on any individual whose treatment we did not observe, then would we find that our estimate of the effect of treatment on that individual is accurate? . Further Readings . For more information on causal inference research and its assumptions and issues, we recommend Imbens, Guido W., and Donald B. Rubin. Causal inference in statistics, social, and biomedical sciences. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Introduction#challenges-in-matching-methods",
    "relUrl": "/user-guide/Introduction#challenges-in-matching-methods"
  },"77": {
    "doc": "Missing Data Handling",
    "title": "Missing Data Handling",
    "content": ". | Introduction to Missing Data Problems in Matching | Determining Which Missing Data Method Is Right For You . | Missing values in the input data | Missing values in the holdout data | . | Further Details on MICE imputation | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Missing-Data",
    "relUrl": "/user-guide/Missing-Data"
  },"78": {
    "doc": "Missing Data Handling",
    "title": "Introduction to Missing Data Problems in Matching",
    "content": "Missing data is a complicated issue in matching problems. Imputing missing values on datasets is possible, but matches become less interpretable when matching on imputed values, in that it is more difficult to discern why a match was recommended by the matching algorithm. The DAME and FLAME algorithms rely on covariate matching, so the DAME-FLAME package is able to take advantage of this and allows users to match on raw values on data sets with missing data without imputing any data. The DAME-FLAME package also provides options for imputing data. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Missing-Data#introduction-to-missing-data-problems-in-matching",
    "relUrl": "/user-guide/Missing-Data#introduction-to-missing-data-problems-in-matching"
  },"79": {
    "doc": "Missing Data Handling",
    "title": "Determining Which Missing Data Method Is Right For You",
    "content": "Missing values in the input data . We recommend users set the parameter missing_data_replace=2, where units that have missing values are still matched on, but the covariates they are missing are not used in computing their match. In this option, the underlying algorithm works by replacing each missing value with a unique value, so that in the matching procedure, those covariates simply don’t have a match because their values are not equl to any other values. It is not recommended to use MICE to impute on the matching dataset, as this would be very slow. Users also have the option of imputing their data through any data imputation method of their choice, and then using their imputed dataset as the input data. | Method | Recommendation | Technical Details | missing_data_replace parameter value | . | Do not match units with missing values | Only use if missing values indicate bad unit | Units in the input dataset that have missing data are dropped from the dataset prior to running the algorithms finding the matches | 1 | . | Match units with missing values, but ignore missing values | Recommended for most cases | When pre-processing the input, we place a unique value in place of each missing data point. This will not match any other value, so a unit will only be matched where it’s non-missing covariates match the non-missing covariates of another unit | 2 | . | Impute missing values with MICE | Not recommended | Creates several imputed datasets and iterates over each to find a match according to each dataset. See below for details. | 3 | . Missing values in the holdout data . The “holdout dataset”, if provided, must have the exact same covariates as the input dataset. It is used when training and fitting a machine learning algorithm to determine the best covariates for predicting the outcome. Matches will always be done on the corresponding covariates, but only on the input dataset. We recommend users set the parameter missing_data_replace=1, where units with missing values are dropped, and these units are not used in determining the best covariate set for predicting the outcome. This is the fastest option for the algorithm’s runtime. The error of the predictions will vary depending on how large and informative the observed, non-missing dataset is. Users also have the option of imputing their data through any data imputation method of their choice, and then using their imputed dataset as the input data. | Method | Recommendation | Technical Details | missing_holdout_replace parameter value | . | Do not match units with missing values | Recommended | Units in the holdout dataset that have missing data are dropped from the dataset prior to running the algorithms finding the matches | 1 | . | Impute missing values with MICE | Recommended if interpretability and speed are lower order priorities | Creates several imputed holdout datasets. When choosing the best covariate set for predicting the outcome, iterates over each imputed dataset, and averages the predictive error over all datasets | 2 | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Missing-Data#determining-which-missing-data-method-is-right-for-you",
    "relUrl": "/user-guide/Missing-Data#determining-which-missing-data-method-is-right-for-you"
  },"80": {
    "doc": "Missing Data Handling",
    "title": "Further Details on MICE imputation",
    "content": "The built-in imputation method that we include is the “Multiple Imputation by Chained Equations” algorithm. This constructs several imputed datasets. It fills in missing values multiple times, creating multiple “complete” datasets. The error of the imputations, and the consistency of the imputations across imputed datasets, is dependent on how predictive the observed data is of the missing values. The underlying MICE implementation is done using scikit learn’s experimental IterativeImpute package, and relies on DecisionTreeRegressions in the imputation process, to ensure that the data generated is fit for unordered categorical data. Further Readings . For more information on the MICE missing data handling technique, we recommend Azur, Melissa J., et al. Multiple imputation by chained equations: what is it and how does it work?. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Missing-Data#further-details-on-mice-imputation",
    "relUrl": "/user-guide/Missing-Data#further-details-on-mice-imputation"
  },"81": {
    "doc": "Whether to use Matching",
    "title": "To Match or Not To Match",
    "content": "That is the question . | Determining Whether to Use Matching Methods . | The Stable Unit Treatment Value Assumption (SUTVA) | The Unconfoundedness Assumption | Overlap of Treatment and Control Groups | . | Additional Requirements For DAME-FLAME | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/to-match-or-not#to-match-or-not-to-match",
    "relUrl": "/user-guide/to-match-or-not#to-match-or-not-to-match"
  },"82": {
    "doc": "Whether to use Matching",
    "title": "Determining Whether to Use Matching Methods",
    "content": "Matching of treatment and control units can be a good method in order to determine treatment effects. However, certain criteria must be upheld in order for matching to be an appropriate solution for a given dataset. If these criteria are not upheld, perhaps other approaches to causal inference should be used in place of, or in addition to matching. The Stable Unit Treatment Value Assumption (SUTVA) . Treatments applied to one unit should not affect the outcome of another unit. Units can not interfere with one another. This is reasonable in many situations: If two individuals are not in contact with each other, how would one individual taking a pain medication impact the outcome of another individual. We should also assume that the treatment doesn’t have varying forms, and is completely binary. Individuals can not have taken pain medication of different strengths. The Unconfoundedness Assumption . This is also referred to as “ignorability”. It is important that the outcome is independent of the treatment when observable covaraiates are held constant. Omitted variable bias is a common issue that occurs when a variable impacts both treatment and outcomes, and appears in a bias of treatment effect estimates. In the example about pain medications, if a researcher fails to include in their dataset some underlying health condition that impacts response to pain medication, the impact of taking pain medication for a headache might be evaluated incorrectly. Overlap of Treatment and Control Groups . A common problem in causal inference is overlap or imbalance between treatment and control groups. A treatment and control group would have no overlap if none of the covariates have the same values. In this case, the FLAME and DAME algorithms would not find any matches, and no treatment effect estimates would be possible. A more moderate issue is partial overlap. In this case, some units do not have matches. Because the DAME-FLAME package allows for algorithm controls, even if all units could be matched in theory, users of the algorithm might prefer to avoid matching all units. Regardless of the cause, units that are unmatched do not have a CATE estimate, and they are not included in the treatment effect calculations either. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/to-match-or-not#determining-whether-to-use-matching-methods",
    "relUrl": "/user-guide/to-match-or-not#determining-whether-to-use-matching-methods"
  },"83": {
    "doc": "Whether to use Matching",
    "title": "Additional Requirements For DAME-FLAME",
    "content": "Since DAME-FLAME is a package for matching treatment and control groups, we require all of the above criteria for users. Additionally, we impose one additional crucial requirement: that the datasets that contain discrete observational data. The outcome variable can be continuous, but we impose this requirement on all of the covariates. We do not recommend users bin continous covariates unless they are confident they are in a way that is a typical, research driven separation. Further Readings . For more information on causal inference research and its assumptions and issues, we recommend Imbens, Guido W., and Donald B. Rubin. Causal inference in statistics, social, and biomedical sciences. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/to-match-or-not#additional-requirements-for-dame-flame",
    "relUrl": "/user-guide/to-match-or-not#additional-requirements-for-dame-flame"
  },"84": {
    "doc": "Whether to use Matching",
    "title": "Whether to use Matching",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/to-match-or-not",
    "relUrl": "/user-guide/to-match-or-not"
  },"85": {
    "doc": "Treatment Effect Estimates",
    "title": "Treatment Effect Estimates",
    "content": "We define and discuss the most common estimands that researchers use to quantify the effect of a treatment. | Notes on Statistical Assumptions . | Unconfoundedness | Overlap of Treatment and Control Groups | . | Notation for Causal Inference | Conditional Average Treatment Effect (CATE) | Average Treatment Effect (ATE) | . ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Treatment-Effects",
    "relUrl": "/user-guide/Treatment-Effects"
  },"86": {
    "doc": "Treatment Effect Estimates",
    "title": "Notes on Statistical Assumptions",
    "content": "Unconfoundedness . As an important note, these metrics will be biased if the unconfoundedness or ignorability assumption does not hold. In other words, it is best to use these metrics if the outcome is independent of the treatment conditioned on the observable covariates. For this reason, it can be good to include as many covariates as possible that may affect the outcome or selection into treatment. In a case where a user is conflicted on whether or not to include a particular covariates, we recommend including it, running FLAME or DAME, and observing how quickly it is dropped via the verbose=3 parameter. If the covariate is dropped in an early iteration with a low predictive error, it can be assumed that covariate is only weakly correlated with the outcome. Users can always match a second time after removing weakly correlated covariates from their dataset, if they wish. We recommend this approach, in order to ensure that any important covariates are matched on and that the bias of these resulting treatment effect estimators is minimized. Overlap of Treatment and Control Groups . A common problem in causal inference is that of overlap or imbalance between treatment and control groups. A treatment and control group have no overlap if none of their (discrete) covariates have the same values. In this setting, FLAME and DAME would not make any matches, and treatment effect estimation would not be possible. A more moderate issue is that of partial overlap, in which some units do not have matches. Because the DAME-FLAME package allows for algorithm controls, even if all units could be matched in theory, users of the algorithm might prefer to avoid matching all units. Regardless of the reason, units that are unmatched do not have a CATE estimate and they are not included in the ATE calculations. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Treatment-Effects#notes-on-statistical-assumptions",
    "relUrl": "/user-guide/Treatment-Effects#notes-on-statistical-assumptions"
  },"87": {
    "doc": "Treatment Effect Estimates",
    "title": "Notation for Causal Inference",
    "content": "We index matched units by $i$, which ranges from 1 to $N$. We may interchangeably refer to the matched units as ‘individuals’ or ‘observations’, where we make implicit the fact that they have been matched; otherwise, they cannot contribute to treatment effect estimates. There are $r$ pre-treatment covariates $x_1, \\dots, x_r$ and for a given unit $i$, we will refer to its vector of covariates as $X_i$. Let the treatment indicator for any unit $i$ be indicated as $T_i$. We let $Y_i$ be the observed outcome for individual $i$ where $Y_i = Y_i(1)T_i + Y_i(0)(1 - T_i)$ and $Y_i(0), Y_i(1)$ are the potential outcomes of unit $i$ under control and treatment, respectively. Lastly, we introduce notation for matched groups, which we index by $m$, which ranges from 1 to $M$. The size of a matched group $m$ is $| m\\vert$, which is the number of units in the group. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Treatment-Effects#notation-for-causal-inference",
    "relUrl": "/user-guide/Treatment-Effects#notation-for-causal-inference"
  },"88": {
    "doc": "Treatment Effect Estimates",
    "title": "Conditional Average Treatment Effect (CATE)",
    "content": "This is defined as the average treatment effect conditional on particular covariates. Formally, the CATE given a set of covariates $X_i$ is: $\\text{CATE}(X_i) = \\frac{1}{N}\\sum_{i=1}^N\\mathbb{E}[Y(1)-Y(0)|X_i]$ . Our implementation of CATE estimation allows users to input a unit $i$ and receive its CATE, based off the covariates it was matched to other units on. Since our units are matched almost-exactly, all units in a given matched group will have the same CATE. For a unit $i$ in matched group $m$ of size $|m|$, we estimate the CATE of unit $i$ as: \\(\\frac{1}{\\|M\\|}\\sum_{i:T_i=1}[\\hat{Y}_i(1)]-\\frac{1}{\\|M\\|}\\sum_{i:T_i=0}[\\hat{Y}_i(0)]\\) . where $\\hat{Y}_i(0), \\hat{Y}_i(1)$ are estimated using the units in $m$ with treatment $1 - T_i$. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Treatment-Effects#conditional-average-treatment-effect-cate",
    "relUrl": "/user-guide/Treatment-Effects#conditional-average-treatment-effect-cate"
  },"89": {
    "doc": "Treatment Effect Estimates",
    "title": "Average Treatment Effect (ATE)",
    "content": "The Average Treatment Effect is defined to be: $\\text{ATE} = \\mathbb{E}[Y(1)-Y(0)]$. Let $q_i$ denote the number of matched groups that unit $i$ appears in. Note this quantity can be greater than 1 in case that matching is done with replacement, via the Repeats = True argument. We then define the weight of a matched group $m$: $w_m=\\sum_{i=1}^{|m|}\\frac{1}{q_i}$. Since the CATE of each unit in a group is the same, we can call the CATE of group $m$ $\\text{CATE}_m$. We estimate ATE as: $\\text{ATE} = \\frac{\\sum_{m}\\text{CATE}m \\times w_m}{\\sum{m}w_m}$. Note that this expression downweights units matched many times so that they do not dominate the ATE estimate. Further Readings . For more information on treatment effects, we recommend Imbens, Guido W. Nonparametric estimation of average treatment effects under exogeneity: A review. ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide/Treatment-Effects#average-treatment-effect-ate",
    "relUrl": "/user-guide/Treatment-Effects#average-treatment-effect-ate"
  },"90": {
    "doc": "User Guide",
    "title": "User Guide",
    "content": " ",
    "url": "http://localhost:4000/DAME-FLAME-Python-Package/user-guide",
    "relUrl": "/user-guide"
  }
}
